-----------------------------------------------
1. multi-threading
2. windows socket programming 
3. serial port communication 
4. designs - solid design principles, couple of design patterns, 
	refactoring 
-----------------------------------------------
Pending 
	STL containers / algorithms / iterators 
	exception - user defined exception class 
-----------------------------------------------	
multi-threading
	- process: is created when program is in exection 
	- part of process, shares memory space of processs 
		- main thread is the default thread 
			from main thread we can go multiple threads 
-----------------------------------------------
	two routines (main) 
		sequential flow 
	two threads 
		main thread 
		worker thread 
			-- synchroization of main and worker 
				by joining 
				
				
		---concurrency of the code flow 
-----------------------------------------------
	thread api 
		url : en.cppreference.com/w/cpp/thread 
		
		<thread> 
			class thread 
-----------------------------------------------			




-----------------------------------------------
two routines (functions) non-threaded 
-----------------------------------------------
#include<iostream>
#include<cstdlib>
#include<windows.h>
using namespace std;

void parentSayHi() {
	for(int I=1; I <= 6; I++){
	Sleep(300);
	cout << "Hi from parent" << endl;
	}
	Sleep(300);
}
void childSayHello() {
	for (int I = 1; I <= 6; I++) {
		Sleep(300);
		cout << "Hello from child" << endl;
	}
	Sleep(300);
}
int main() {
	cout << "Waiting...." << endl;
	childSayHello();
	parentSayHi();
	return EXIT_SUCCESS;
}



-----------------------------------------------
two routines (functions) threaded 
-----------------------------------------------
#include<iostream>
#include<cstdlib>
#include<windows.h>
#include<thread>
using namespace std;

void parentSayHi() {
	for (int I = 1; I <= 6; I++) {
		Sleep(300);
		cout << "Hi from parent" << endl;
	}
	Sleep(300);
}
void childSayHello() {
	for (int I = 1; I <= 6; I++) {
		Sleep(300);
		cout << "Hello from child" << endl;
	}
	Sleep(300);
}
int main() {
	cout << "Non-threaded...." << endl;
	childSayHello();
	parentSayHi();

	cout << "Threaded....manager(worker)-worker" << endl;
	thread child(childSayHello); //worker -- peer 
	parentSayHi();//manager became worker -- peer
	child.join();//synchronization 


	return EXIT_SUCCESS;
}






-----------------------------------------------
three routines (functions) threaded 
    actual task 
-----------------------------------------------
#include<iostream>
#include<cstdlib>
#include<windows.h>
#include<thread>
using namespace std;

void parentSayHi() {
	int sum = 0;
	for(int I=1; I <= 100000; I++){
	//Sleep(300);
	//cout << "Hi " << I << " . ";
		sum += I;
	}
	cout << "The sum(parent) is " << sum << endl;
	//Sleep(300);
}
void childSayHello() {
	int sum = 0;
	for (int I = 1; I <= 100000; I++) {
		//Sleep(300);
		//cout << "Hello " << I << " . " ;
		sum += I;
	}
	//Sleep(300);
	cout << "The sum(hello child) is " << sum << endl;
}
void childSayMorning() {
	int sum = 0;
	for (int I = 1; I <= 100000; I++) {
		//Sleep(300);
		//cout << "Morning " << I << " . ";
		sum += I;
	}
	//Sleep(300);
	cout << "The sum(morning child) is " << sum << endl;
}
int main() {
	cout << "Waiting...." << endl;
	for(int J = 1; J <= 10; J++){
		cout << "Concurrency #" << J << endl << endl;
		thread child(childSayHello);//worker
		thread childTwo(childSayMorning);//worker
		parentSayHi();//manager
		child.join();//synchroization 
		childTwo.join();
	}
	return EXIT_SUCCESS;
}